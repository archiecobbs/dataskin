/*
 * Copyright (C) 2024 Archie L. Cobbs. All rights reserved.
 */

package org.dellroad.dataskin.viewer.basic;

import com.google.common.base.Preconditions;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.dellroad.dataskin.ops.Operation;
import org.dellroad.dataskin.ops.StaticAction;
import org.dellroad.dataskin.ops.StaticQuery;
import org.dellroad.dataskin.viewer.basic.annotation.DataViewerNode;
import org.dellroad.dataskin.viewer.data.AbstractDataHooks;
import org.dellroad.dataskin.viewer.data.DataHooks;
import org.dellroad.dataskin.viewer.data.NavNode;
import org.dellroad.dataskin.viewer.data.NavNodeImpl;

/**
 * {@link DataHooks} implementation that is generated by analyzing a type hierarchy for
 * {@link DataViewerNode @DataViewerNode} annotations.
 */
public class BasicDataHooks extends AbstractDataHooks {

    private final HashMap<Class<?>, Node> nodeMap = new HashMap<>();

    // Cached info
    private final HashMap<Class<?>, List<QueryMethodScanner<?>.QueryInfo<?, ?>>> queryInfoMap = new HashMap<>();
    private final HashMap<Class<?>, List<ActionMethodScanner<?>.ActionInfo<?, ?>>> actionInfoMap = new HashMap<>();
    private final HashMap<Class<?>, List<Operation<?, ?>>> operationMap = new HashMap<>();

    /**
     * Constructor.
     *
     * @param entityTypes entity types
     */
    public BasicDataHooks(Set<? extends Class<?>> entityTypes) {
        Preconditions.checkArgument(entityTypes != null, "null entityTypes");

        // Find @DataViewerNode annotations and create corresponding entity nodes
        entityTypes.stream()
          .forEach(type -> {
            final DataViewerNode annotation = type.getAnnotation(DataViewerNode.class);
            if (annotation != null)
                this.nodeMap.put(type, new Node(type, annotation.value()));
          });

        // Build parent mapping
        final HashMap<Class<?>, Class<?>> parentMap = new HashMap<>();
        for (Class<?> child : nodeMap.keySet()) {
            Class<?> parent = null;
            for (Class<?> other : nodeMap.keySet()) {
                if (this.isStrictAncestor(other, child)) {
                    if (parent == null || this.isStrictAncestor(parent, other))
                        parent = other;
                }
            }
            parentMap.put(child, parent);
        }

        // Build child mapping
        final HashMap<Class<?>, List<Class<?>>> childMap = new HashMap<>();
        for (Class<?> parent : nodeMap.keySet()) {
            final List<Class<?>> childList = parentMap.entrySet().stream()
              .filter(entry -> entry.getValue() == parent)
              .map(Map.Entry::getKey)
              .collect(Collectors.toList());
            childMap.put(parent, childList);
        }

        // Configure nodes
        this.nodeMap.forEach((type, node) -> {

            // Build child list
            node.setChildNodes(childMap.get(type).stream()
              .map(this.nodeMap::get)
              .collect(Collectors.toList()));

            // Configure the node's operations based on the annotated methods
            node.setStaticQueries(this.getOperations(type, StaticQuery.class)
              .map(query -> (StaticQuery<?, ?>)query)
              .collect(Collectors.toList()));
            node.setStaticActions(this.getOperations(type, StaticAction.class)
              .map(action -> (StaticAction<?, ?>)action)
              .collect(Collectors.toList()));
        });
    }

    // Is c1 an ancestor of c2?
    private boolean isStrictAncestor(Class<?> c1, Class<?> c2) {
        return c1.isAssignableFrom(c2) && !c2.isAssignableFrom(c1);
    }

    /**
     * Determine if the given query is a candidate as the default {@link StaticQuery} for the given entity type.
     *
     * <p>
     * It will have already been determined that {@code query} doesn't
     * {@linkplain StaticQuery#requiresConfiguration require configuration}.
     *
     * <p>
     * The implementation in {@link BasicDataHooks} returns true if {@code type} equals the query's result type.
     *
     * @param type entity type
     * @param query query
     */
    protected boolean isDefaultQueryCandidate(Class<?> type, StaticQuery<?, ?> query) {
        return type == query.getResultType().getRawType();
    }

    @SuppressWarnings("unchecked")
    <T extends Operation<?, ?>> Stream<T> getOperations(Class<?> type, Class<T> operationType) {
        return this.operationMap.computeIfAbsent(type, this::findOperationsOnType)
          .stream()
          .filter(operationType::isInstance)
          .map(operationType::cast);
    }

    private List<Operation<?, ?>> findOperationsOnType(Class<?> type) {
        return Stream.<AbstractMethodScanner<?, ?>.OperationInfo<?, ?>>concat(
          this.queryInfoMap.computeIfAbsent(type,
            c -> new QueryMethodScanner<>(c).queryInfos().collect(Collectors.toList())).stream(),
          this.actionInfoMap.computeIfAbsent(type,
            c -> new ActionMethodScanner<>(c).actionInfos().collect(Collectors.toList())).stream())
          .map(info -> info.getOperation(this))
          .collect(Collectors.toList());
    }

    public Map<Class<?>, Node> getNodeMap() {
        return Collections.unmodifiableMap(nodeMap);
    }

// DataHooks

    @Override
    public Stream<? extends NavNode> getRootNavNodes() {
        return this.nodeMap.values().stream();
    }

// Node

    public class Node extends NavNodeImpl {

        private final Class<?> type;

        Node(Class<?> type, String label) {
            this.type = type;
            this.setLabel(label);
        }

        public Class<?> getType() {
            return this.type;
        }

        public BasicDataHooks getDataHooks() {
            return BasicDataHooks.this;
        }

        @Override
        protected boolean isDefaultQueryCandidate(StaticQuery<?, ?> query) {
            return super.isDefaultQueryCandidate(query) && BasicDataHooks.this.isDefaultQueryCandidate(this.type, query);
        }
    }
}
